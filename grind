#!/usr/bin/env python3

import os
import sys
import json
import argparse
import subprocess
import math
import time as time_module
from datetime import datetime, timedelta

PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
MEMORY_FILE = os.path.join(PROJECT_ROOT, 'memory.md')
ARCHIVE_FILE = os.path.join(PROJECT_ROOT, 'memory_archive.md')
CONFIG_FILE = os.path.join(PROJECT_ROOT, '.lc_config.json')
PROBLEMS_FILE = os.path.join(PROJECT_ROOT, 'problems.json')
ARCHIVE_THRESHOLD = 50

# ANSI Colors
CYAN = '\033[96m'
GREEN = '\033[92m'
RED = '\033[91m'
YELLOW = '\033[93m'
MAGENTA = '\033[95m'
BOLD = '\033[1m'
DIM = '\033[2m'
RESET = '\033[0m'


def print_info(msg):
    print(f"{CYAN}[INFO] {msg}{RESET}")


def print_success(msg):
    print(f"{GREEN}[OK] {msg}{RESET}")


def print_error(msg):
    print(f"{RED}[ERROR] {msg}{RESET}", file=sys.stderr)


def print_warn(msg):
    print(f"{YELLOW}[WARN] {msg}{RESET}")


def slug_to_folder(slug):
    """Convert a slug like 'two-sum' to folder name 'two_sum'."""
    return slug.replace('-', '_')


def resolve_problem_dir(slug):
    """Resolve a slug to its problem directory path."""
    folder = slug_to_folder(slug)
    return os.path.join(PROJECT_ROOT, 'problems', folder)


def find_solution_file(problem_dir):
    """Find the solution file in a problem directory."""
    for name in ['solution.cpp', 'solution.py', 'Solution.java']:
        path = os.path.join(problem_dir, name)
        if os.path.exists(path):
            return path
    return None


# --- Config ---

def load_config():
    """Load config from .lc_config.json."""
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    return {"active_track": "blind75"}


def save_config(config):
    """Save config to .lc_config.json."""
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)
        f.write('\n')


# --- Problem Bank ---

def load_problems():
    """Load problems.json."""
    if not os.path.exists(PROBLEMS_FILE):
        print_error(f"Problem bank not found: {PROBLEMS_FILE}")
        return None
    with open(PROBLEMS_FILE, 'r') as f:
        return json.load(f)


# --- Commands ---

def cmd_init(args):
    """First-time setup: create memory.md, config, print welcome."""
    created = []

    if not os.path.exists(MEMORY_FILE):
        with open(MEMORY_FILE, 'w') as f:
            f.write('# LeetCode Progress\n\n')
            f.write('| Slug | Topic | Difficulty | Date | Rating | Time | Hints | Ease | Interval | Next Review |\n')
            f.write('|------|-------|------------|------|--------|------|-------|------|----------|-------------|\n')
        created.append('memory.md')

    if not os.path.exists(CONFIG_FILE):
        save_config({"active_track": "blind75"})
        created.append('.lc_config.json')

    os.makedirs(os.path.join(PROJECT_ROOT, 'problems'), exist_ok=True)

    print()
    print(f"  {BOLD}{GREEN}leet-coach{RESET} initialized!")
    print()
    if created:
        for f in created:
            print(f"  {DIM}Created {f}{RESET}")
        print()

    print(f"  {BOLD}Quick start:{RESET}")
    print(f"    {CYAN}/solve two-sum cpp{RESET}     Start your first problem")
    print(f"    {CYAN}grind list{RESET}             Browse the problem bank")
    print(f"    {CYAN}grind progress{RESET}         Check your progress")
    print()
    print(f"  {DIM}Active track: Blind 75 (switch with: grind track <name>){RESET}")
    print()


def cmd_new(args):
    """Creates a new problem folder from template."""
    slug = args.slug
    lang = args.lang

    config = {
        'python': {'ext': 'py', 'template': 'templates/python.txt', 'filename': 'solution.py'},
        'cpp': {'ext': 'cpp', 'template': 'templates/cpp.txt', 'filename': 'solution.cpp'},
        'java': {'ext': 'java', 'template': 'templates/java.txt', 'filename': 'Solution.java'},
    }

    template_path = os.path.join(PROJECT_ROOT, config[lang]['template'])
    problem_dir = resolve_problem_dir(slug)
    solution_file = os.path.join(problem_dir, config[lang]['filename'])
    input_file = os.path.join(problem_dir, 'input.txt')

    if os.path.exists(solution_file):
        print_error(f"Solution already exists: {solution_file}")
        return

    if not os.path.exists(template_path):
        print_error(f"Template not found: {template_path}")
        return

    # Create problem directory
    os.makedirs(problem_dir, exist_ok=True)

    # Read template
    with open(template_path, 'r') as f:
        content = f.read()

    # Replace placeholders
    class_name = "Solution"
    folder_name = slug_to_folder(slug)
    content = content.replace("{{PROBLEM_NAME}}", slug)
    content = content.replace("{{PROBLEM_SLUG}}", slug)
    content = content.replace("{{PROBLEM_CLASS}}", class_name)
    content = content.replace("{{PROBLEM_FOLDER}}", folder_name)

    # Write solution file
    with open(solution_file, 'w') as f:
        f.write(content)

    # Write input file (empty)
    if not os.path.exists(input_file):
        with open(input_file, 'w') as f:
            f.write("")

    print_success(f"Created {solution_file}")
    print_success(f"Created {input_file}")

    # Try to open in VS Code
    try:
        subprocess.run(['code', solution_file, input_file], check=False,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except FileNotFoundError:
        pass


def cmd_run(args):
    """Runs the problem file."""
    slug_or_file = args.filename

    # First try: resolve as slug to problem directory
    problem_dir = resolve_problem_dir(slug_or_file)
    solution_file = find_solution_file(problem_dir) if os.path.isdir(problem_dir) else None

    if not solution_file:
        # Try the raw slug without dash-to-underscore conversion
        raw_dir = os.path.join(PROJECT_ROOT, 'problems', slug_or_file)
        if os.path.isdir(raw_dir):
            solution_file = find_solution_file(raw_dir)
            if solution_file:
                problem_dir = raw_dir

    if not solution_file:
        # Legacy fallback: try as direct file path
        filename = slug_or_file
        if not os.path.exists(filename):
            candidate = os.path.join(PROJECT_ROOT, 'problems', filename)
            if os.path.exists(candidate):
                filename = candidate
            else:
                found = False
                for ext in ['.py', '.cpp', '.java']:
                    candidate_ext = os.path.join(PROJECT_ROOT, 'problems', filename + ext)
                    if os.path.exists(candidate_ext):
                        filename = candidate_ext
                        found = True
                        break
                if not found:
                    alt = filename.replace('-', '_')
                    for ext in ['.py', '.cpp', '.java']:
                        candidate_ext = os.path.join(PROJECT_ROOT, 'problems', alt + ext)
                        if os.path.exists(candidate_ext):
                            filename = candidate_ext
                            found = True
                            break
                if not found:
                    print_error(f"Problem '{slug_or_file}' not found.")
                    print(f"\n  {DIM}Make sure you've scaffolded it first:{RESET}")
                    print(f"  {CYAN}grind new {slug_or_file} cpp{RESET}\n")
                    return
        _run_file(filename)
        return

    _run_file(solution_file)


def _run_file(filename):
    """Execute a solution file with elapsed time reporting."""
    ext = os.path.splitext(filename)[1]
    problem_dir = os.path.dirname(filename)
    input_file = os.path.join(problem_dir, 'input.txt')

    # Legacy fallback for flat files
    if not os.path.exists(input_file):
        input_file = os.path.splitext(filename)[0] + '.txt'

    stdin_file = None
    if os.path.exists(input_file) and os.path.getsize(input_file) > 0:
        print_info(f"Reading input from {os.path.basename(input_file)}...")
        stdin_file = open(input_file, 'r')

    start_time = time_module.time()

    try:
        if ext == '.py':
            env = os.environ.copy()
            env['PYTHONPATH'] = PROJECT_ROOT + os.pathsep + env.get('PYTHONPATH', '')
            subprocess.run(['python3', filename], env=env, stdin=stdin_file)

        elif ext == '.cpp':
            out_bin = os.path.join(PROJECT_ROOT, 'a.out')
            print_info("Compiling C++...")
            cmd = ['g++', '-std=c++17', filename, '-o', out_bin]
            res = subprocess.run(cmd)

            if res.returncode == 0:
                print_info("Running...")
                subprocess.run([out_bin], stdin=stdin_file)
                if os.path.exists(out_bin):
                    os.remove(out_bin)
            else:
                print_error("Compilation failed.")
                return

        elif ext == '.java':
            print_info("Compiling Java...")
            utils_java = os.path.join(PROJECT_ROOT, 'utils/java/LcUtils.java')
            cmd = ['javac', '-cp', PROJECT_ROOT, filename, utils_java]
            res = subprocess.run(cmd, cwd=PROJECT_ROOT)

            if res.returncode == 0:
                print_info("Running...")
                rel = os.path.relpath(filename, PROJECT_ROOT)
                classname = os.path.splitext(rel)[0].replace(os.sep, '.')
                subprocess.run(['java', '-cp', PROJECT_ROOT, classname],
                               cwd=PROJECT_ROOT, stdin=stdin_file)
            else:
                print_error("Compilation failed.")
                return

        else:
            print_error(f"Unsupported extension: {ext}")
            return

    except KeyboardInterrupt:
        print("\nStopped.")
    finally:
        if stdin_file:
            stdin_file.close()

    elapsed = time_module.time() - start_time
    if elapsed < 1:
        print(f"\n{DIM}Elapsed: {elapsed*1000:.0f}ms{RESET}")
    else:
        print(f"\n{DIM}Elapsed: {elapsed:.2f}s{RESET}")


# --- SM-2 Spaced Repetition ---

def sm2_calculate(rating, prev_ease=2.5, prev_interval=0, repetition=0):
    """
    SM-2 algorithm. Returns (new_ease, new_interval, new_repetition).
    Rating: 1-5 (maps to SM-2 quality 0-5 with 1->1, 5->5).
    """
    quality = rating

    new_ease = prev_ease + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))
    new_ease = max(1.3, new_ease)

    if quality < 3:
        new_repetition = 0
        new_interval = 1
    else:
        new_repetition = repetition + 1
        if new_repetition == 1:
            new_interval = 1
        elif new_repetition == 2:
            new_interval = 6
        else:
            new_interval = math.ceil(prev_interval * new_ease)

    return new_ease, new_interval, new_repetition


def parse_memory():
    """Parse memory.md and return list of row dicts."""
    if not os.path.exists(MEMORY_FILE):
        return []

    with open(MEMORY_FILE, 'r') as f:
        lines = f.readlines()

    rows = []
    in_table = False
    for line in lines:
        stripped = line.strip()
        if stripped.startswith('| Slug'):
            in_table = True
            continue
        if in_table and stripped.startswith('|---'):
            continue
        if in_table and stripped.startswith('|'):
            cells = [c.strip() for c in stripped.split('|')[1:-1]]
            if len(cells) >= 10:
                rows.append({
                    'slug': cells[0],
                    'topic': cells[1],
                    'difficulty': cells[2],
                    'date': cells[3],
                    'rating': int(cells[4]),
                    'time': cells[5],
                    'hints': int(cells[6]) if cells[6] else 0,
                    'ease': float(cells[7]),
                    'interval': cells[8],
                    'next_review': cells[9],
                })
        elif in_table and not stripped.startswith('|'):
            in_table = False

    return rows


def write_memory(rows):
    """Write rows back to memory.md."""
    lines = ['# LeetCode Progress\n', '\n']
    lines.append('| Slug | Topic | Difficulty | Date | Rating | Time | Hints | Ease | Interval | Next Review |\n')
    lines.append('|------|-------|------------|------|--------|------|-------|------|----------|-------------|\n')

    for r in rows:
        lines.append(
            f"| {r['slug']} | {r['topic']} | {r['difficulty']} | {r['date']} "
            f"| {r['rating']} | {r['time']} | {r['hints']} | {r['ease']:.1f} "
            f"| {r['interval']} | {r['next_review']} |\n"
        )

    with open(MEMORY_FILE, 'w') as f:
        f.writelines(lines)


def cmd_log(args):
    """Log a solved problem with SM-2 spaced repetition."""
    slug = args.slug
    rating = args.rating
    time_spent = f"{args.time}m" if args.time else ""
    hints = args.hints if args.hints is not None else 0
    topic = args.topic or ""
    difficulty = args.difficulty or ""

    rows = parse_memory()

    # Find previous entry for this slug to get SM-2 state
    prev = None
    for r in rows:
        if r['slug'] == slug:
            prev = r

    if prev:
        prev_ease = prev['ease']
        interval_str = prev['interval'].rstrip('d')
        prev_interval = int(interval_str) if interval_str else 0
        repetition = sum(1 for r in rows if r['slug'] == slug)
        if not topic:
            topic = prev['topic']
        if not difficulty:
            difficulty = prev['difficulty']
    else:
        prev_ease = 2.5
        prev_interval = 0
        repetition = 0

    # Try to fill topic/difficulty from problems.json if not provided
    if (not topic or not difficulty):
        bank = load_problems()
        if bank:
            for track_data in bank.get('tracks', {}).values():
                for p in track_data.get('problems', []):
                    if p['slug'] == slug:
                        if not topic:
                            topic = p.get('topic', '')
                        if not difficulty:
                            difficulty = p.get('difficulty', '')
                        break

    new_ease, new_interval, _ = sm2_calculate(rating, prev_ease, prev_interval, repetition)

    today = datetime.now().strftime('%Y-%m-%d')
    next_review = (datetime.now() + timedelta(days=new_interval)).strftime('%Y-%m-%d')

    new_row = {
        'slug': slug,
        'topic': topic,
        'difficulty': difficulty,
        'date': today,
        'rating': rating,
        'time': time_spent,
        'hints': hints,
        'ease': new_ease,
        'interval': f"{new_interval}d",
        'next_review': next_review,
    }

    rows.append(new_row)
    write_memory(rows)

    print_success(f"Logged {slug}: rating={rating}, ease={new_ease:.1f}, interval={new_interval}d, next review={next_review}")

    if len(rows) > ARCHIVE_THRESHOLD:
        cmd_archive(None)


def cmd_archive(args):
    """Move oldest rows from memory.md to memory_archive.md when over threshold."""
    rows = parse_memory()

    if len(rows) <= ARCHIVE_THRESHOLD:
        print_info(f"Only {len(rows)} rows, no archiving needed (threshold: {ARCHIVE_THRESHOLD}).")
        return

    to_archive = rows[:len(rows) - ARCHIVE_THRESHOLD]
    to_keep = rows[len(rows) - ARCHIVE_THRESHOLD:]

    archive_lines = []
    if os.path.exists(ARCHIVE_FILE):
        with open(ARCHIVE_FILE, 'r') as f:
            archive_lines = f.readlines()

    if not archive_lines:
        archive_lines = [
            '# LeetCode Progress Archive\n', '\n',
            '| Slug | Topic | Difficulty | Date | Rating | Time | Hints | Ease | Interval | Next Review |\n',
            '|------|-------|------------|------|--------|------|-------|------|----------|-------------|\n',
        ]

    for r in to_archive:
        archive_lines.append(
            f"| {r['slug']} | {r['topic']} | {r['difficulty']} | {r['date']} "
            f"| {r['rating']} | {r['time']} | {r['hints']} | {r['ease']:.1f} "
            f"| {r['interval']} | {r['next_review']} |\n"
        )

    with open(ARCHIVE_FILE, 'w') as f:
        f.writelines(archive_lines)

    write_memory(to_keep)
    print_success(f"Archived {len(to_archive)} rows to memory_archive.md")


def cmd_list(args):
    """List problems from the active track (or specified track), with solved status."""
    bank = load_problems()
    if not bank:
        return

    config = load_config()
    track_name = args.track or config.get('active_track', 'blind75')
    topic_filter = args.topic.lower() if args.topic else None
    difficulty_filter = args.difficulty.lower() if args.difficulty else None

    tracks = bank.get('tracks', {})
    if track_name not in tracks:
        print_error(f"Track '{track_name}' not found.")
        print(f"  {DIM}Available tracks: {', '.join(tracks.keys())}{RESET}")
        return

    track = tracks[track_name]
    problems = track['problems']

    # Filter
    if topic_filter:
        problems = [p for p in problems if p.get('topic', '').lower() == topic_filter]
    if difficulty_filter:
        problems = [p for p in problems if p.get('difficulty', '').lower() == difficulty_filter]

    if not problems:
        print_info("No problems match the filters.")
        return

    # Get solved slugs from memory
    rows = parse_memory()
    solved_slugs = set(r['slug'] for r in rows)

    # Group by topic
    by_topic = {}
    for p in problems:
        topic = p.get('topic', 'other')
        by_topic.setdefault(topic, []).append(p)

    solved_count = sum(1 for p in problems if p['slug'] in solved_slugs)
    total = len(problems)

    print(f"\n  {BOLD}{track['name']}{RESET} {DIM}({solved_count}/{total} solved){RESET}\n")

    diff_colors = {'easy': GREEN, 'medium': YELLOW, 'hard': RED}

    for topic in sorted(by_topic.keys()):
        topic_problems = by_topic[topic]
        print(f"  {BOLD}{MAGENTA}{topic}{RESET}")
        for p in topic_problems:
            slug = p['slug']
            diff = p.get('difficulty', '')
            number = p.get('number', '')
            check = f"{GREEN}*{RESET}" if slug in solved_slugs else f"{DIM}.{RESET}"
            dc = diff_colors.get(diff, '')
            num_str = f"#{number}" if number else ""
            print(f"    {check} {slug} {DIM}{num_str}{RESET} {dc}{diff}{RESET}")
        print()

    print(f"  {DIM}Filter: grind list --topic <topic> --difficulty <easy|medium|hard>{RESET}")
    print()


def cmd_track(args):
    """View or switch active track."""
    bank = load_problems()
    if not bank:
        return

    config = load_config()
    tracks = bank.get('tracks', {})

    if args.name:
        # Switch track
        if args.name not in tracks:
            print_error(f"Track '{args.name}' not found.")
            print(f"  {DIM}Available tracks: {', '.join(tracks.keys())}{RESET}")
            return
        config['active_track'] = args.name
        save_config(config)
        track = tracks[args.name]
        print_success(f"Switched to {track['name']} ({len(track['problems'])} problems)")
    else:
        # Show current track info
        current = config.get('active_track', 'blind75')
        print(f"\n  {BOLD}Active track:{RESET} {current}")
        print(f"\n  {BOLD}Available tracks:{RESET}")
        for key, track in tracks.items():
            marker = f" {GREEN}<-{RESET}" if key == current else ""
            print(f"    {CYAN}{key}{RESET} — {track['name']} ({len(track['problems'])} problems){marker}")
        print(f"\n  {DIM}Switch: grind track <name>{RESET}\n")


def cmd_progress(args):
    """Show progress summary: due reviews, recent solves, streak, track progress."""
    rows = parse_memory()

    if not rows:
        print_info("No problems logged yet. Start with: /solve <slug> <lang>")
        return

    today = datetime.now().date()
    config = load_config()
    active_track = config.get('active_track', 'blind75')

    # Due for review
    due = []
    for r in rows:
        try:
            review_date = datetime.strptime(r['next_review'], '%Y-%m-%d').date()
            if review_date <= today:
                days_overdue = (today - review_date).days
                due.append((r['slug'], r['topic'], days_overdue))
        except ValueError:
            pass

    # Recent solves (last 7 days)
    recent = []
    for r in rows:
        try:
            solve_date = datetime.strptime(r['date'], '%Y-%m-%d').date()
            if (today - solve_date).days <= 7:
                recent.append((r['slug'], r['date'], r['rating']))
        except ValueError:
            pass

    # Streak
    solve_dates = set()
    for r in rows:
        try:
            solve_dates.add(datetime.strptime(r['date'], '%Y-%m-%d').date())
        except ValueError:
            pass

    streak = 0
    check_date = today
    while check_date in solve_dates:
        streak += 1
        check_date -= timedelta(days=1)

    # Unique problems solved
    unique_slugs = set(r['slug'] for r in rows)

    # Track progress
    bank = load_problems()
    track_info = ""
    next_unsolved = None
    if bank:
        tracks = bank.get('tracks', {})
        if active_track in tracks:
            track = tracks[active_track]
            track_problems = track['problems']
            track_solved = sum(1 for p in track_problems if p['slug'] in unique_slugs)
            track_total = len(track_problems)
            track_info = f"{track['name']}: {track_solved}/{track_total}"
            # Find next unsolved
            for p in track_problems:
                if p['slug'] not in unique_slugs:
                    next_unsolved = p
                    break

    # Print summary
    print(f"\n{BOLD}Progress{RESET}")
    print(f"{DIM}{'─' * 40}{RESET}\n")

    print(f"  {BOLD}Problems solved:{RESET} {len(unique_slugs)}")
    if track_info:
        print(f"  {BOLD}Track progress:{RESET} {track_info}")
    print(f"  {BOLD}Current streak:{RESET} {streak} day{'s' if streak != 1 else ''}")
    print()

    if due:
        due.sort(key=lambda x: -x[2])
        print(f"  {YELLOW}{BOLD}Due for review:{RESET}")
        for slug, topic, overdue in due:
            if overdue > 0:
                print(f"    - {slug} ({topic}) — overdue by {overdue}d")
            else:
                print(f"    - {slug} ({topic}) — due today")
        print()
    else:
        print(f"  {GREEN}No reviews due today.{RESET}\n")

    if recent:
        print(f"  {BOLD}Recent solves (last 7d):{RESET}")
        for slug, date, rating in recent:
            print(f"    - {slug} on {date} (rating: {rating}/5)")
        print()

    # Suggestions
    if due:
        print(f"  {CYAN}{BOLD}Suggested next:{RESET} Review {due[0][0]} ({due[0][1]})")
    elif next_unsolved:
        slug = next_unsolved['slug']
        topic = next_unsolved.get('topic', '')
        diff = next_unsolved.get('difficulty', '')
        print(f"  {CYAN}{BOLD}Suggested next:{RESET} {slug} ({topic}, {diff})")
    else:
        topic_counts = {}
        for r in rows:
            if r['topic']:
                topic_counts[r['topic']] = topic_counts.get(r['topic'], 0) + 1
        if topic_counts:
            least = min(topic_counts, key=topic_counts.get)
            print(f"  {CYAN}{BOLD}Suggested next:{RESET} Practice more {least} problems")

    print()


# --- Main ---

def main():
    parser = argparse.ArgumentParser(
        prog='grind',
        description='Your AI coding coach that never gives you the answer.',
        epilog='Start a coaching session: /solve <slug> <lang>',
    )
    subparsers = parser.add_subparsers(dest='command')

    # init
    subparsers.add_parser('init', help='First-time setup')

    # new
    new_parser = subparsers.add_parser('new', help='Create a new problem workspace')
    new_parser.add_argument('slug', help='Problem slug (e.g. two-sum)')
    new_parser.add_argument('lang', choices=['python', 'cpp', 'java'], help='Language')

    # run
    run_parser = subparsers.add_parser('run', help='Run solution (auto-reads from input.txt)')
    run_parser.add_argument('filename', help='Problem slug or filename')

    # log
    log_parser = subparsers.add_parser('log', help='Log a solved problem')
    log_parser.add_argument('slug', help='Problem slug')
    log_parser.add_argument('rating', type=int, choices=[1, 2, 3, 4, 5], help='Self-assessment (1-5)')
    log_parser.add_argument('--time', type=int, help='Time spent in minutes')
    log_parser.add_argument('--hints', type=int, default=0, help='Number of hints used')
    log_parser.add_argument('--topic', type=str, help='Problem topic (e.g. arrays, dp)')
    log_parser.add_argument('--difficulty', type=str, help='Difficulty (easy, medium, hard)')

    # list
    list_parser = subparsers.add_parser('list', help='Browse problem bank')
    list_parser.add_argument('--track', type=str, help='Track name (default: active track)')
    list_parser.add_argument('--topic', type=str, help='Filter by topic')
    list_parser.add_argument('--difficulty', type=str, help='Filter by difficulty')

    # track
    track_parser = subparsers.add_parser('track', help='View or switch active track')
    track_parser.add_argument('name', nargs='?', help='Track name to switch to')

    # archive
    subparsers.add_parser('archive', help='Archive old rows from memory.md')

    # progress
    subparsers.add_parser('progress', help='Show progress summary')

    args = parser.parse_args()

    commands = {
        'init': cmd_init,
        'new': cmd_new,
        'run': cmd_run,
        'log': cmd_log,
        'list': cmd_list,
        'track': cmd_track,
        'archive': cmd_archive,
        'progress': cmd_progress,
    }

    handler = commands.get(args.command)
    if handler:
        handler(args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
